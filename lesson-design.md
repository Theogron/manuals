# Lesson design

This is a checklist and hints when writing and designing a new lesson.
The master material is in Teaching Tech Together, primarily chapters 6
and 12 for practicalities and 2 and 4 for big picture considerations.
But really, all the book.  See [the summary we
made](teaching-tech-together.md) or [the actual
book](http://teachtogether.tech/).

## Backwards lesson design.

Think test-driven development: decide what you want students to be able
to do, design exercises to measure it, then fill in the gaps with
teaching.  You can see [their
summary](http://teachtogether.tech/en/template/).

- Brainstorm what you want to cover
- Create or reuse learner personas
- Create formative assessments (exercises) that let the learners
  practice what you want them to learn.  See below for hints on coming
  up with good exercises.
- Put exercises in a logical order, and fill in any gaps.  Ideally
  there should be 15-20 min of teaching between each.  Not every one
  has to be very long
- Write just enough material to get from one exercise to the other.


## Planning

- Do some planning, and *document it* - the design process helps
  others to teach and modify.  At least put it in the README.
- Also make a *guide* for teaching.
- Make learner personas: what is your target audience?
- Decide learning objectives based on the personas: high-level end
  goals.  What students get out, not what they do.

## Writing

Not much here yet, mostly just follow the "backwards lesson design"
above.  The hardest part is coming up with good exercises, so our
practical advice is to mix and max from the two taxonomies at the
bottom and the exercise types.  Try to think of diverse types of
exercises.

## Exercise types

The main point of different exercises types is to have some which have
lower cognitive load.

- Multiple choice (easy to get feedback via a classroom tool)
- Code yourself (traditional programming)
- Code yourself + multiple choice to see what the answer is (allows
  you to get feedback)
- Inverted coding (given code, have to debug)
- Parsons problems (working solution but lines in random order,
  learner must only put in proper order)
- Fill in the blank

- Tracing execution
- Tracing values through code flow (e.g. what is the sequence of
  values that `x` takes on?)
- Reverse execution (find input that gives an output)
- Minimal fix (given broken code, make it work)
- Theme and variations (working code, adapt to other type of
  situation/problem)
- Refactoring

- Draw a diagram
- Label diagram
- Matching problem: two sets of Q/A, match them.


## Reference material
- Bloom's taxonomy: hierarchical skill levels
  - Remembering
  - Understanding
  - Applying
  - Analyzing
  - Evaluating
  - Creating
- Fink's taxonomy: complementary types instead of hierarchical:
  - Foundational knowledge
  - Applications
  - Integration
  - Human dimension
  - Caring
  - Learning how to learn
